# SYS-402 Assessment 1 - Here comes the hea<u>R</u>ty <u>AID</u>!

The goal of this assessment is to evaluate your understanding on multiple-disk systems and see whether you are able to design a multiple-disk system under given constraints.

There will be two parts in this assessment: (1) multiple-disk system design, and (2) multiple-disk system implementation.

## Part 1 - Multiple-Disk System Design (50 points)
You will be given three scenarios. You need to design an appropriate multiple-disk system for each scenario. Additionally, you need to quantitatively analyze your design againsts the given constraints to convince whether your design is appropriate. You may want to use real-world data to support your answer.

Please put your answer in `part1/scenario-[q].md` where `[q]` is the scenario number.

### Scenario 1 - HeartyTube for Speed (10 points)
Alice would like to store HeartyTube's comments for doing [sentiment analysis](https://en.wikipedia.org/wiki/Sentiment_analysis). She collected more than 10 trillion comments (around 100 bytes each; 100 TB in total). At first, she used JBOD to build a virtual drive out of her 100 1-TB HDDs. However, she found that her system takes at least 1 week to analyze all of these data. Suppose that she used the fastest data structure and algorithm to analyze the data, how should she improve her system to decrease the analysis time. Note that she does not have much budget left.

### Scenario 2 - HeartyShop for Reliability (10 points)
Bob owns an e-commerce platform, HeartyShop. His platform is so popular that it receives around 1 million transactions per day. Given this amount of data, he decided to implement his own storage system having a bunch of disks. Recently, he found that he lost some of the data due to disk failure. If he does not change, he may get sued by his clients. He hires you to design the system for making his system more reliable. How should he improve his system? An additional budget would not be a problem unless it is not reasonable.

### Scenario 3 - HeartyPay for Both (30 points)
HeartyPay system is a payment system, which is similar to [PromptPay](https://www.bot.or.th/en/financial-innovation/digital-finance/digital-payment/promptpay.html). The key difference is that HeartyPay is aimed to be global, which means it needs to be a lot more scalable (i.e., 1 trillion transactions per day). More importantly, all the transactions generated by the HeartyPay cannot be lost and the payment must be quick enough.

HeartyPay was fortunate enough that it received a donation of 90 1-TB HDDs and 10 1-TB NAND Flash SSDs. There are also some hardware disk array controllers. How should we design the HeartyPay system so that it has decent performance while maintaining (almost) perfect reliability and data integrity?

## Part 2 - Implementing a (hopefully-)high-availability object store manager through redundancy (50 points)
You will be building an object store, namely <i>hearty-store</i>, (i.e., think about the Google drive without directories, or AWS S3 buckets). Each object can be identified (i.e., accessed) through its identifier. To simplify, the storage space for this object store will be broken down into a linear array of 1024 1-MB blocks. <b>More importantly, only one object is allowed for one block.</b> If the object cannot fit into a single 1-MB block, the system will deny the object (i.e., users have to handle this by themselves).

The special capability of this object store is that it can build redundancy by doing replication and parity.

### Task #1 - Build the object store (20 points)
Implement the *persistent* object store. You need to make sure that the object store is implemented according to the requirements above. More importantly, you should be able to create multiple instances of this object store. To create an instance of the object store, you need to implement `hearty-store-init` as a program to initialize it.

```sh
hearty-store-init [store-id]
```

This command should initialize the linear array and all the necessary metadata. The linear array can be implemented as a single 1024-MB file.

Moreover, you also need to implement `hearty-store-put`, and `hearty-store-get`. When running those commands, you should be able to specify `store-id` to pick the instance you want to use. Please look at the following details to see more.

The `hearty-store-put` should have one argument, which is the original file path. Or basically, it should be something like this.

```sh
hearty-store-put [store-id] [original file path]
```

It should return a unique identifier (i.e., does not need to be unique across instances) of the object back to the user. For flexibility, you can use anything as the identifier (including, an integer, a string). I suggest you generate a unique identifier on the fly as an integer. Note that if the user uses `hearty-store-put` onto any existing unique identifier, **the new object will replace the old object**.


For the `hearty-store-get`, the user should be able to use it as follows.

```sh
hearty-store-get [store-id] [unique identifier]
```

It should *give* you the file. The word *give* here might be ambiguous. To *give* here is to display all the data onto the console. If you want to test whether the data is read correctly or not, you may want to redirect it to another file and compare using `diff`.

```sh
hearty-store-get [store-id] [unique identifier] > ./tmp
diff [original file path] ./tmp
```

Lastly, you should have another 2 programs to list all the instances (`hearty-store-list`), and destroy a store (`hearty-store-destroy`). These two programs should be used as follows.

```sh
# List all the store identifiers
hearty-store-list

# Destroy one of the instances
hearty-store-destroy [store-id]
```

More importantly, `hearty-store-destroy` must destroy all the files (objects, metadata) related to the destroyed instance.

### Task #2 - Create a pair of mirrored stores (10 points)
You should be able to create a replica of an instance. Note that this replica should **always be identical** to the original instance when accessing with `hearty-store-get`. Also, users must be able to mutate this replica using `hearty-store-put` and the mutation must be propagated to the original instance.

More specifically, you need to implement `hearty-store-replicate`, which allows users to do the above action. Users should be able to use the program as follows.

```
hearty-store-replicate [store-id]
```

It should return the `store-id` for the replica instance so that the user can use the replica.

Note that when you destroy either the original instance or the replica instance, **the other one should also be destroyed**.

### Task #3 - Build parity among multiple stores (20 points)
Also, the object store must be able to create a group of **high-availablity** instances by building a parity file based on them. Users should be able to use this feature through `hearty-store-ha` following by a list of `store-id` in the group. For example,

```sh
hearty-store-ha 1 2 3
```

The above command will create a group of three instances (which are stores 1, 2, and 3) and a parity file based on them. The parity file will be 1024 MB large. It will be computed by XORing a bit from each store together, similarly to the parity disk in class.

#### Subtask #3.1 - Create a parity when doing fault-free write (5 points)
When doing `hearty-store-put` (for either creating or modifying an object), the parity file may need to be recomputed accordingly.

#### Subtask #3.2 - Implement degraded read and write (10 points)
When one of the instances in the group is destroyed, the group will change into the *degrade* mode. When listing all the instances, the user should be able to see the destroyed instance, perhaps as follows.

```sh
1 - ha-group=1
2 - ha-group=1
3 - ha-group=1, destroyed
```

This means the user should be able to access the destroyed instance via `hearty-store-get` and `hearty-store-put` normally. But, it will not be a general `hearty-store-get` and `hearty-store-put`, since the data are not available. You need to reconstruct the data based on the data from the other instances in the same group and the parity file.

However, if more than one instances in the same group are destroyed, **the high-availability group will need to be destroyed too**.

### Extra Credit - Support store rebuild (5 points)
You may want to implement `hearty-store-rebuild` that allows the user to rebuild the destroyed instance in the high-availability group.

### Code Style
You should follow a good coding convention. In this class, please stick with the CMU 15-213's Code Style.

https://www.cs.cmu.edu/afs/cs/academic/class/15213-f24/www/codeStyle.html

### Programming Language
You can use C, C++, Rust to implement this project. Other programming languages rather than these must be approved by the instructor first. (But, definitely, Python cannot)

### Submission
Please put all of your code and **instructions to run the code** in the `part2/`. You should describe a bit on your code structure so that it is easy for me to navigate through your code when grading. All of the instructions and descriptions should be in `part2/README.md`.